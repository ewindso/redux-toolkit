{"version":3,"sources":["../../../src/query/react/index.ts","../../../src/query/react/buildHooks.ts","../../../src/query/react/useShallowStableValue.ts","../../../src/query/react/constants.ts","../../../src/query/endpointDefinitions.ts","../../../src/query/utils/capitalize.ts","../../../src/query/tsHelpers.ts","../../../src/query/react/module.ts","../../../src/query/react/ApiProvider.tsx"],"names":["coreModule","buildCreateApi","createSelector","useCallback","useEffect2","useLayoutEffect","useMemo","useRef2","useState","QueryStatus","skipToken","shallowEqual2","useEffect","useRef","shallowEqual","useShallowStableValue","value","cache","current","DefinitionType","DefinitionType2","UNINITIALIZED_VALUE","Symbol","defaultQueryStateSelector","x","defaultMutationStateSelector","queryStatePreSelector","currentState","lastResult","_a","data","isSuccess","isFetching","isLoading","__objSpread","noPendingQueryStateSelector","selected","isUninitialized","status","pending","capitalize","str","replace","toUpperCase","safeAssign","target","args","Object","assign","rrUseDispatch","rrUseSelector","rrUseStore","rrBatch","reactHooksModuleName","reactHooksModule","batch","useDispatch","useSelector","useStore","name","[object Object]","api","options","context","anyApi","buildQueryHooks","buildMutationHook","usePrefetch","moduleOptions","useQuerySubscription","arg","refetchOnReconnect","refetchOnFocus","refetchOnMountOrArgChange","skip","pollingInterval","initiate","endpoints","dispatch","stableArg","stableSubscriptionOptions","promiseRef","lastPromise","unsubscribe","lastSubscriptionOptions","subscriptionOptions","updateSubscriptionOptions","promise","forceRefetch","refetch","useLazyQuerySubscription","setArg","_b","subscriptionOptionsRef","trigger","arg2","preferCacheValue","useQueryState","selectFromResult","select","lastValue","selectDefaultResult","_","querySelector","state","store","newLastValue","getState","queryStateResults","info","lastArg","querySubscriptionResults","requestId","setRequestId","triggerMutation","mutationSelector","subState","endpointName","defaultOptions","stableDefaultOptions","util","prefetch","buildHooks","definition","type","query","useQuery","useLazyQuery","mutation","useMutation","from","configureStore","React","Provider","setupListeners","ApiProvider","props","reducer","reducerPath","middleware","gDM","concat","createElement","children","createApi"],"mappings":"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","sourcesContent":["import { coreModule, buildCreateApi, CreateApi } from '@reduxjs/toolkit/query'\nimport { reactHooksModule, reactHooksModuleName } from './module'\n\nimport type { MutationHooks, QueryHooks } from './buildHooks'\nimport type {\n  EndpointDefinitions,\n  QueryDefinition,\n  MutationDefinition,\n  QueryArgFrom,\n} from '@reduxjs/toolkit/dist/query/endpointDefinitions'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/dist/query/baseQueryTypes'\n\nimport type { QueryKeys } from '@reduxjs/toolkit/dist/query/core/apiState'\nimport type { PrefetchOptions } from '@reduxjs/toolkit/dist/query/core/module'\n\nexport * from '@reduxjs/toolkit/query'\nexport { ApiProvider } from './ApiProvider'\n\nconst createApi = /* @__PURE__ */ buildCreateApi(\n  coreModule(),\n  reactHooksModule()\n)\n\nexport { createApi, reactHooksModule }\n","import type { AnyAction, ThunkAction, ThunkDispatch } from '@reduxjs/toolkit'\nimport { createSelector } from '@reduxjs/toolkit'\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport { QueryStatus, skipToken } from '@reduxjs/toolkit/query'\nimport type {\n  QuerySubState,\n  SubscriptionOptions,\n  QueryKeys,\n  RootState,\n} from '@reduxjs/toolkit/dist/query/core/apiState'\nimport type {\n  EndpointDefinitions,\n  MutationDefinition,\n  QueryDefinition,\n  QueryArgFrom,\n  ResultTypeFrom,\n} from '@reduxjs/toolkit/dist/query/endpointDefinitions'\nimport type {\n  QueryResultSelectorResult,\n  MutationResultSelectorResult,\n  SkipToken,\n} from '@reduxjs/toolkit/dist/query/core/buildSelectors'\nimport type {\n  QueryActionCreatorResult,\n  MutationActionCreatorResult,\n} from '@reduxjs/toolkit/dist/query/core/buildInitiate'\nimport { shallowEqual } from 'react-redux'\nimport type { Api } from '@reduxjs/toolkit/dist/query/apiTypes'\nimport type {\n  Id,\n  NoInfer,\n  Override,\n} from '@reduxjs/toolkit/dist/query/tsHelpers'\nimport type {\n  ApiEndpointMutation,\n  ApiEndpointQuery,\n  CoreModule,\n  PrefetchOptions,\n} from '@reduxjs/toolkit/dist/query/core/module'\nimport type { ReactHooksModuleOptions } from './module'\nimport { useShallowStableValue } from './useShallowStableValue'\nimport type { UninitializedValue } from './constants'\nimport { UNINITIALIZED_VALUE } from './constants'\n\nexport interface QueryHooks<\n  Definition extends QueryDefinition<any, any, any, any, any>\n> {\n  useQuery: UseQuery<Definition>\n  useLazyQuery: UseLazyQuery<Definition>\n  useQuerySubscription: UseQuerySubscription<Definition>\n  useLazyQuerySubscription: UseLazyQuerySubscription<Definition>\n  useQueryState: UseQueryState<Definition>\n}\n\nexport interface MutationHooks<\n  Definition extends MutationDefinition<any, any, any, any, any>\n> {\n  useMutation: UseMutation<Definition>\n}\n\n/**\n * A React hook that automatically triggers fetches of data from an endpoint, 'subscribes' the component to the cached data, and reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available.\n *\n * The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already, and the hook will return the data for that query arg once it's available.\n *\n * This hook combines the functionality of both [`useQueryState`](#usequerystate) and [`useQuerySubscription`](#usequerysubscription) together, and is intended to be used in the majority of situations.\n *\n * #### Features\n *\n * - Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default\n * - 'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts\n * - Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met\n * - Returns the latest request status and cached data from the Redux store\n * - Re-renders as the request status changes and data becomes available\n */\nexport type UseQuery<D extends QueryDefinition<any, any, any, any>> = <\n  R extends Record<string, any> = UseQueryStateDefaultResult<D>\n>(\n  arg: QueryArgFrom<D> | SkipToken,\n  options?: UseQuerySubscriptionOptions & UseQueryStateOptions<D, R>\n) => UseQueryStateResult<D, R> & ReturnType<UseQuerySubscription<D>>\n\ninterface UseQuerySubscriptionOptions extends SubscriptionOptions {\n  /**\n   * Prevents a query from automatically running.\n   *\n   * @remarks\n   * When `skip` is true (or `skipToken` is passed in as `arg`):\n   *\n   * - **If the query has cached data:**\n   *   * The cached data **will not be used** on the initial load, and will ignore updates from any identical query until the `skip` condition is removed\n   *   * The query will have a status of `uninitialized`\n   *   * If `skip: false` is set after skipping the initial load, the cached result will be used\n   * - **If the query does not have cached data:**\n   *   * The query will have a status of `uninitialized`\n   *   * The query will not exist in the state when viewed with the dev tools\n   *   * The query will not automatically fetch on mount\n   *   * The query will not automatically run when additional components with the same query are added that do run\n   *\n   * @example\n   * ```tsx\n   * // codeblock-meta title=\"Skip example\"\n   * const Pokemon = ({ name, skip }: { name: string; skip: boolean }) => {\n   *   const { data, error, status } = useGetPokemonByNameQuery(name, {\n   *     skip,\n   *   });\n   *\n   *   return (\n   *     <div>\n   *       {name} - {status}\n   *     </div>\n   *   );\n   * };\n   * ```\n   */\n  skip?: boolean\n  /**\n   * Defaults to `false`. This setting allows you to control whether if a cached result is already available, RTK Query will only serve a cached result, or if it should `refetch` when set to `true` or if an adequate amount of time has passed since the last successful query result.\n   * - `false` - Will not cause a query to be performed _unless_ it does not exist yet.\n   * - `true` - Will always refetch when a new subscriber to a query is added. Behaves the same as calling the `refetch` callback or passing `forceRefetch: true` in the action creator.\n   * - `number` - **Value is in seconds**. If a number is provided and there is an existing query in the cache, it will compare the current time vs the last fulfilled timestamp, and only refetch if enough time has elapsed.\n   *\n   * If you specify this option alongside `skip: true`, this **will not be evaluated** until `skip` is false.\n   */\n  refetchOnMountOrArgChange?: boolean | number\n}\n\n/**\n * A React hook that automatically triggers fetches of data from an endpoint, and 'subscribes' the component to the cached data.\n *\n * The query arg is used as a cache key. Changing the query arg will tell the hook to re-fetch the data if it does not exist in the cache already.\n *\n * Note that this hook does not return a request status or cached data. For that use-case, see [`useQuery`](#usequery) or [`useQueryState`](#usequerystate).\n *\n * #### Features\n *\n * - Automatically triggers requests to retrieve data based on the hook argument and whether cached data exists by default\n * - 'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts\n * - Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met\n */\nexport type UseQuerySubscription<\n  D extends QueryDefinition<any, any, any, any>\n> = (\n  arg: QueryArgFrom<D> | SkipToken,\n  options?: UseQuerySubscriptionOptions\n) => Pick<QueryActionCreatorResult<D>, 'refetch'>\n\nexport type UseLazyQueryLastPromiseInfo<\n  D extends QueryDefinition<any, any, any, any>\n> = {\n  lastArg: QueryArgFrom<D>\n}\n\n/**\n * A React hook similar to [`useQuery`](#usequery), but with manual control over when the data fetching occurs.\n *\n * This hook includes the functionality of [`useLazyQuerySubscription`](#uselazyquerysubscription).\n *\n * #### Features\n *\n * - Manual control over firing a request to retrieve data\n * - 'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts\n * - Returns the latest request status and cached data from the Redux store\n * - Re-renders as the request status changes and data becomes available\n * - Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met and the fetch has been manually called at least once\n *\n */\nexport type UseLazyQuery<D extends QueryDefinition<any, any, any, any>> = <\n  R = UseQueryStateDefaultResult<D>\n>(\n  options?: SubscriptionOptions & Omit<UseQueryStateOptions<D, R>, 'skip'>\n) => [\n  (arg: QueryArgFrom<D>) => void,\n  UseQueryStateResult<D, R>,\n  UseLazyQueryLastPromiseInfo<D>\n]\n\n/**\n * A React hook similar to [`useQuerySubscription`](#usequerysubscription), but with manual control over when the data fetching occurs.\n *\n * Note that this hook does not return a request status or cached data. For that use-case, see [`useLazyQuery`](#uselazyquery).\n *\n * #### Features\n *\n * - Manual control over firing a request to retrieve data\n * - 'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts\n * - Accepts polling/re-fetching options to trigger automatic re-fetches when the corresponding criteria is met and the fetch has been manually called at least once\n */\nexport type UseLazyQuerySubscription<\n  D extends QueryDefinition<any, any, any, any>\n> = (\n  options?: SubscriptionOptions\n) => [(arg: QueryArgFrom<D>) => void, QueryArgFrom<D> | UninitializedValue]\n\nexport type QueryStateSelector<\n  R extends Record<string, any>,\n  D extends QueryDefinition<any, any, any, any>\n> = (state: UseQueryStateDefaultResult<D>) => R\n\n/**\n * A React hook that reads the request status and cached data from the Redux store. The component will re-render as the loading status changes and the data becomes available.\n *\n * Note that this hook does not trigger fetching new data. For that use-case, see [`useQuery`](#usequery) or [`useQuerySubscription`](#usequerysubscription).\n *\n * #### Features\n *\n * - Returns the latest request status and cached data from the Redux store\n * - Re-renders as the request status changes and data becomes available\n */\nexport type UseQueryState<D extends QueryDefinition<any, any, any, any>> = <\n  R = UseQueryStateDefaultResult<D>\n>(\n  arg: QueryArgFrom<D> | SkipToken,\n  options?: UseQueryStateOptions<D, R>\n) => UseQueryStateResult<D, R>\n\nexport type UseQueryStateOptions<\n  D extends QueryDefinition<any, any, any, any>,\n  R extends Record<string, any>\n> = {\n  /**\n   * Prevents a query from automatically running.\n   *\n   * @remarks\n   * When skip is true:\n   *\n   * - **If the query has cached data:**\n   *   * The cached data **will not be used** on the initial load, and will ignore updates from any identical query until the `skip` condition is removed\n   *   * The query will have a status of `uninitialized`\n   *   * If `skip: false` is set after skipping the initial load, the cached result will be used\n   * - **If the query does not have cached data:**\n   *   * The query will have a status of `uninitialized`\n   *   * The query will not exist in the state when viewed with the dev tools\n   *   * The query will not automatically fetch on mount\n   *   * The query will not automatically run when additional components with the same query are added that do run\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta title=\"Skip example\"\n   * const Pokemon = ({ name, skip }: { name: string; skip: boolean }) => {\n   *   const { data, error, status } = useGetPokemonByNameQuery(name, {\n   *     skip,\n   *   });\n   *\n   *   return (\n   *     <div>\n   *       {name} - {status}\n   *     </div>\n   *   );\n   * };\n   * ```\n   */\n  skip?: boolean\n  /**\n   * `selectFromResult` allows you to get a specific segment from a query result in a performant manner.\n   * When using this feature, the component will not rerender unless the underlying data of the selected item has changed.\n   * If the selected item is one element in a larger collection, it will disregard changes to elements in the same collection.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta title=\"Using selectFromResult to extract a single result\"\n   * function PostsList() {\n   *   const { data: posts } = api.useGetPostsQuery();\n   *\n   *   return (\n   *     <ul>\n   *       {posts?.data?.map((post) => (\n   *         <PostById key={post.id} id={post.id} />\n   *       ))}\n   *     </ul>\n   *   );\n   * }\n   *\n   * function PostById({ id }: { id: number }) {\n   *   // Will select the post with the given id, and will only rerender if the given posts data changes\n   *   const { post } = api.useGetPostsQuery(undefined, {\n   *     selectFromResult: ({ data }) => ({ post: data?.find((post) => post.id === id) }),\n   *   });\n   *\n   *   return <li>{post?.name}</li>;\n   * }\n   * ```\n   */\n  selectFromResult?: QueryStateSelector<R, D>\n}\n\nexport type UseQueryStateResult<\n  _ extends QueryDefinition<any, any, any, any>,\n  R\n> = NoInfer<R>\n\ntype UseQueryStateBaseResult<\n  D extends QueryDefinition<any, any, any, any>\n> = QuerySubState<D> & {\n  /**\n   * Query has not started yet.\n   */\n  isUninitialized: false\n  /**\n   * Query is currently loading for the first time. No data yet.\n   */\n  isLoading: false\n  /**\n   * Query is currently fetching, but might have data from an earlier request.\n   */\n  isFetching: false\n  /**\n   * Query has data from a successful load.\n   */\n  isSuccess: false\n  /**\n   * Query is currently in \"error\" state.\n   */\n  isError: false\n}\n\ntype UseQueryStateDefaultResult<\n  D extends QueryDefinition<any, any, any, any>\n> = Id<\n  | Override<\n      Extract<\n        UseQueryStateBaseResult<D>,\n        { status: QueryStatus.uninitialized }\n      >,\n      { isUninitialized: true }\n    >\n  | Override<\n      UseQueryStateBaseResult<D>,\n      | { isLoading: true; isFetching: boolean; data: undefined }\n      | ({ isSuccess: true; isFetching: boolean; error: undefined } & Required<\n          Pick<UseQueryStateBaseResult<D>, 'data' | 'fulfilledTimeStamp'>\n        >)\n      | ({ isError: true } & Required<\n          Pick<UseQueryStateBaseResult<D>, 'error'>\n        >)\n    >\n> & {\n  /**\n   * @deprecated will be removed in the next version\n   * please use the `isLoading`, `isFetching`, `isSuccess`, `isError`\n   * and `isUninitialized` flags instead\n   */\n  status: QueryStatus\n}\n\nexport type MutationStateSelector<\n  R extends Record<string, any>,\n  D extends MutationDefinition<any, any, any, any>\n> = (state: MutationResultSelectorResult<D>) => R\n\nexport type UseMutationStateOptions<\n  D extends MutationDefinition<any, any, any, any>,\n  R extends Record<string, any>\n> = {\n  selectFromResult?: MutationStateSelector<R, D>\n}\n\nexport type UseMutationStateResult<\n  _ extends MutationDefinition<any, any, any, any>,\n  R\n> = NoInfer<R>\n\n/**\n * A React hook that lets you trigger an update request for a given endpoint, and subscribes the component to read the request status from the Redux store. The component will re-render as the loading status changes.\n *\n * #### Features\n *\n * - Manual control over firing a request to alter data on the server or possibly invalidate the cache\n * - 'Subscribes' the component to keep cached data in the store, and 'unsubscribes' when the component unmounts\n * - Returns the latest request status and cached data from the Redux store\n * - Re-renders as the request status changes and data becomes available\n */\nexport type UseMutation<D extends MutationDefinition<any, any, any, any>> = <\n  R extends Record<string, any> = MutationResultSelectorResult<D>\n>(\n  options?: UseMutationStateOptions<D, R>\n) => [\n  (arg: QueryArgFrom<D>) => MutationActionCreatorResult<D>,\n  UseMutationStateResult<D, R>\n]\n\nconst defaultQueryStateSelector: QueryStateSelector<any, any> = (x) => x\nconst defaultMutationStateSelector: MutationStateSelector<any, any> = (x) => x\n\nconst queryStatePreSelector = (\n  currentState: QueryResultSelectorResult<any>,\n  lastResult: UseQueryStateDefaultResult<any>\n): UseQueryStateDefaultResult<any> => {\n  // data is the last known good request result we have tracked - or if none has been tracked yet the last good result for the current args\n  const data =\n    (currentState.isSuccess ? currentState.data : lastResult?.data) ??\n    currentState.data\n\n  // isFetching = true any time a request is in flight\n  const isFetching = currentState.isLoading\n  // isLoading = true only when loading while no data is present yet (initial load with no data in the cache)\n  const isLoading = !data && isFetching\n  // isSuccess = true when data is present\n  const isSuccess = currentState.isSuccess || (isFetching && !!data)\n\n  return {\n    ...currentState,\n    data,\n    isFetching,\n    isLoading,\n    isSuccess,\n  } as UseQueryStateDefaultResult<any>\n}\n\n/**\n * Wrapper around `defaultQueryStateSelector` to be used in `useQuery`.\n * We want the initial render to already come back with\n * `{ isUninitialized: false, isFetching: true, isLoading: true }`\n * to prevent that the library user has to do an additional check for `isUninitialized`/\n */\nconst noPendingQueryStateSelector: QueryStateSelector<any, any> = (\n  selected\n) => {\n  if (selected.isUninitialized) {\n    return {\n      ...selected,\n      isUninitialized: false,\n      isFetching: true,\n      isLoading: true,\n      status: QueryStatus.pending,\n    } as any\n  }\n  return selected\n}\n\ntype GenericPrefetchThunk = (\n  endpointName: any,\n  arg: any,\n  options: PrefetchOptions\n) => ThunkAction<void, any, any, AnyAction>\n\n/**\n *\n * @param opts.api - An API with defined endpoints to create hooks for\n * @param opts.moduleOptions.batch - The version of the `batchedUpdates` function to be used\n * @param opts.moduleOptions.useDispatch - The version of the `useDispatch` hook to be used\n * @param opts.moduleOptions.useSelector - The version of the `useSelector` hook to be used\n * @returns An object containing functions to generate hooks based on an endpoint\n */\nexport function buildHooks<Definitions extends EndpointDefinitions>({\n  api,\n  moduleOptions: { batch, useDispatch, useSelector, useStore },\n}: {\n  api: Api<any, Definitions, any, any, CoreModule>\n  moduleOptions: Required<ReactHooksModuleOptions>\n}) {\n  return { buildQueryHooks, buildMutationHook, usePrefetch }\n\n  function usePrefetch<EndpointName extends QueryKeys<Definitions>>(\n    endpointName: EndpointName,\n    defaultOptions?: PrefetchOptions\n  ) {\n    const dispatch = useDispatch<ThunkDispatch<any, any, AnyAction>>()\n    const stableDefaultOptions = useShallowStableValue(defaultOptions)\n\n    return useCallback(\n      (arg: any, options?: PrefetchOptions) =>\n        dispatch(\n          (api.util.prefetch as GenericPrefetchThunk)(endpointName, arg, {\n            ...stableDefaultOptions,\n            ...options,\n          })\n        ),\n      [endpointName, dispatch, stableDefaultOptions]\n    )\n  }\n\n  function buildQueryHooks(name: string): QueryHooks<any> {\n    const useQuerySubscription: UseQuerySubscription<any> = (\n      arg: any,\n      {\n        refetchOnReconnect,\n        refetchOnFocus,\n        refetchOnMountOrArgChange,\n        skip = false,\n        pollingInterval = 0,\n      } = {}\n    ) => {\n      const { initiate } = api.endpoints[name] as ApiEndpointQuery<\n        QueryDefinition<any, any, any, any, any>,\n        Definitions\n      >\n      const dispatch = useDispatch<ThunkDispatch<any, any, AnyAction>>()\n      const stableArg = useShallowStableValue(skip ? skipToken : arg)\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n      })\n\n      const promiseRef = useRef<QueryActionCreatorResult<any>>()\n\n      useEffect(() => {\n        const lastPromise = promiseRef.current\n\n        if (stableArg === skipToken) {\n          lastPromise?.unsubscribe()\n          promiseRef.current = undefined\n          return\n        }\n\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions\n\n        if (!lastPromise || lastPromise.arg !== stableArg) {\n          lastPromise?.unsubscribe()\n          const promise = dispatch(\n            initiate(stableArg, {\n              subscriptionOptions: stableSubscriptionOptions,\n              forceRefetch: refetchOnMountOrArgChange,\n            })\n          )\n          promiseRef.current = promise\n        } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          lastPromise.updateSubscriptionOptions(stableSubscriptionOptions)\n        }\n      }, [\n        dispatch,\n        initiate,\n        refetchOnMountOrArgChange,\n        stableArg,\n        stableSubscriptionOptions,\n      ])\n\n      useEffect(() => {\n        return () => {\n          promiseRef.current?.unsubscribe()\n          promiseRef.current = undefined\n        }\n      }, [])\n\n      return useMemo(\n        () => ({\n          /**\n           * A method to manually refetch data for the query\n           */\n          refetch: () => void promiseRef.current?.refetch(),\n        }),\n        []\n      )\n    }\n\n    const useLazyQuerySubscription: UseLazyQuerySubscription<any> = ({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval = 0,\n    } = {}) => {\n      const { initiate } = api.endpoints[name] as ApiEndpointQuery<\n        QueryDefinition<any, any, any, any, any>,\n        Definitions\n      >\n      const dispatch = useDispatch<ThunkDispatch<any, any, AnyAction>>()\n\n      const [arg, setArg] = useState<any>(UNINITIALIZED_VALUE)\n      const promiseRef = useRef<QueryActionCreatorResult<any> | undefined>()\n\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n      })\n\n      useEffect(() => {\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions\n\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          promiseRef.current?.updateSubscriptionOptions(\n            stableSubscriptionOptions\n          )\n        }\n      }, [stableSubscriptionOptions])\n\n      const subscriptionOptionsRef = useRef(stableSubscriptionOptions)\n      useEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions\n      }, [stableSubscriptionOptions])\n\n      const trigger = useCallback(\n        function (arg: any, preferCacheValue = false) {\n          batch(() => {\n            promiseRef.current?.unsubscribe()\n\n            promiseRef.current = dispatch(\n              initiate(arg, {\n                subscriptionOptions: subscriptionOptionsRef.current,\n                forceRefetch: !preferCacheValue,\n              })\n            )\n            setArg(arg)\n          })\n        },\n        [dispatch, initiate]\n      )\n\n      /* cleanup on unmount */\n      useEffect(() => {\n        return () => {\n          promiseRef?.current?.unsubscribe()\n        }\n      }, [])\n\n      /* if \"cleanup on unmount\" was triggered from a fast refresh, we want to reinstate the query */\n      useEffect(() => {\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n          trigger(arg, true)\n        }\n      }, [arg, trigger])\n\n      return useMemo(() => [trigger, arg], [trigger, arg])\n    }\n\n    const useQueryState: UseQueryState<any> = (\n      arg: any,\n      { skip = false, selectFromResult = defaultQueryStateSelector } = {}\n    ) => {\n      const { select } = api.endpoints[name] as ApiEndpointQuery<\n        QueryDefinition<any, any, any, any, any>,\n        Definitions\n      >\n      const stableArg = useShallowStableValue(skip ? skipToken : arg)\n\n      const lastValue = useRef<any>()\n\n      const selectDefaultResult = useMemo(\n        () =>\n          createSelector(\n            [select(stableArg), (_: any, lastResult: any) => lastResult],\n            queryStatePreSelector\n          ),\n        [select, stableArg]\n      )\n\n      const querySelector = useMemo(\n        () => createSelector([selectDefaultResult], selectFromResult),\n        [selectDefaultResult, selectFromResult]\n      )\n\n      const currentState = useSelector(\n        (state: RootState<Definitions, any, any>) =>\n          querySelector(state, lastValue.current),\n        shallowEqual\n      )\n\n      const store = useStore()\n      const newLastValue = selectDefaultResult(\n        store.getState(),\n        lastValue.current\n      )\n      useLayoutEffect(() => {\n        lastValue.current = newLastValue\n      }, [newLastValue])\n\n      return currentState\n    }\n\n    return {\n      useQueryState,\n      useQuerySubscription,\n      useLazyQuerySubscription,\n      useLazyQuery(options) {\n        const [trigger, arg] = useLazyQuerySubscription(options)\n        const queryStateResults = useQueryState(arg, {\n          ...options,\n          skip: arg === UNINITIALIZED_VALUE,\n        })\n\n        const info = useMemo(() => ({ lastArg: arg }), [arg])\n        return useMemo(() => [trigger, queryStateResults, info], [\n          trigger,\n          queryStateResults,\n          info,\n        ])\n      },\n      useQuery(arg, options) {\n        const querySubscriptionResults = useQuerySubscription(arg, options)\n        const queryStateResults = useQueryState(arg, {\n          selectFromResult:\n            arg === skipToken || options?.skip\n              ? undefined\n              : noPendingQueryStateSelector,\n          ...options,\n        })\n        return useMemo(\n          () => ({ ...queryStateResults, ...querySubscriptionResults }),\n          [queryStateResults, querySubscriptionResults]\n        )\n      },\n    }\n  }\n\n  function buildMutationHook(name: string): UseMutation<any> {\n    return ({ selectFromResult = defaultMutationStateSelector } = {}) => {\n      const { select, initiate } = api.endpoints[name] as ApiEndpointMutation<\n        MutationDefinition<any, any, any, any, any>,\n        Definitions\n      >\n      const dispatch = useDispatch<ThunkDispatch<any, any, AnyAction>>()\n      const [requestId, setRequestId] = useState<string>()\n\n      const promiseRef = useRef<MutationActionCreatorResult<any>>()\n\n      useEffect(() => {\n        return () => {\n          promiseRef.current?.unsubscribe()\n          promiseRef.current = undefined\n        }\n      }, [])\n\n      const triggerMutation = useCallback(\n        function (arg) {\n          let promise: MutationActionCreatorResult<any>\n          batch(() => {\n            promiseRef?.current?.unsubscribe()\n            promise = dispatch(initiate(arg))\n            promiseRef.current = promise\n            setRequestId(promise.requestId)\n          })\n          return promise!\n        },\n        [dispatch, initiate]\n      )\n\n      const mutationSelector = useMemo(\n        () =>\n          createSelector([select(requestId || skipToken)], (subState) =>\n            selectFromResult(subState)\n          ),\n        [select, requestId, selectFromResult]\n      )\n\n      const currentState = useSelector(mutationSelector, shallowEqual)\n\n      return useMemo(() => [triggerMutation, currentState], [\n        triggerMutation,\n        currentState,\n      ])\n    }\n  }\n}\n","import { useEffect, useRef } from 'react'\nimport { shallowEqual } from 'react-redux'\n\nexport function useShallowStableValue<T>(value: T) {\n  const cache = useRef(value)\n  useEffect(() => {\n    if (!shallowEqual(cache.current, value)) {\n      cache.current = value\n    }\n  }, [value])\n\n  return shallowEqual(cache.current, value) ? cache.current : value\n}\n","export const UNINITIALIZED_VALUE = Symbol()\nexport type UninitializedValue = typeof UNINITIALIZED_VALUE\n","import type { AnyAction, ThunkDispatch } from '@reduxjs/toolkit'\nimport type { RootState } from './core/apiState'\nimport type {\n  BaseQueryExtraOptions,\n  BaseQueryFn,\n  BaseQueryResult,\n  BaseQueryArg,\n  BaseQueryApi,\n  QueryReturnValue,\n  BaseQueryError,\n  BaseQueryMeta,\n} from './baseQueryTypes'\nimport type {\n  HasRequiredProps,\n  MaybePromise,\n  OmitFromUnion,\n  CastAny,\n} from './tsHelpers'\nimport type { NEVER } from './fakeBaseQuery'\n\nconst resultType = /* @__PURE__ */ Symbol()\nconst baseQuery = /* @__PURE__ */ Symbol()\n\ninterface EndpointDefinitionWithQuery<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  ResultType\n> {\n  /**\n   * `query` can be a function that returns either a `string` or an `object` which is passed to your `baseQuery`. If you are using [fetchBaseQuery](./fetchBaseQuery), this can return either a `string` or an `object` of properties in `FetchArgs`. If you use your own custom [`baseQuery`](../../rtk-query/usage/customizing-queries), you can customize this behavior to your liking.\n   *\n   * @example\n   *\n   * ```ts\n   * // codeblock-meta title=\"query example\"\n   *\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       // highlight-start\n   *       query: () => 'posts',\n   *       // highlight-end\n   *     })\n   *   })\n   * })\n   * ```\n   */\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>\n  queryFn?: never\n  /**\n   * A function to manipulate the data returned by a query or mutation.\n   */\n  transformResponse?(\n    baseQueryReturnValue: BaseQueryResult<BaseQuery>,\n    meta: BaseQueryMeta<BaseQuery>\n  ): ResultType | Promise<ResultType>\n}\n\ninterface EndpointDefinitionWithQueryFn<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  ResultType\n> {\n  /**\n   * Can be used in place of `query` as an inline function that bypasses `baseQuery` completely for the endpoint.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta title=\"Basic queryFn example\"\n   *\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       query: () => 'posts',\n   *     }),\n   *     flipCoin: build.query<'heads' | 'tails', void>({\n   *       // highlight-start\n   *       queryFn(arg, queryApi, extraOptions, baseQuery) {\n   *         const randomVal = Math.random()\n   *         if (randomVal < 0.45) {\n   *           return { data: 'heads' }\n   *         }\n   *         if (randomVal < 0.9) {\n   *           return { data: 'tails' }\n   *         }\n   *         return { error: { status: 500, data: \"Coin landed on it's edge!\" } }\n   *       }\n   *       // highlight-end\n   *     })\n   *   })\n   * })\n   * ```\n   */\n  queryFn(\n    arg: QueryArg,\n    api: BaseQueryApi,\n    extraOptions: BaseQueryExtraOptions<BaseQuery>,\n    baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>\n  ): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>>>\n  query?: never\n  transformResponse?: never\n}\n\nexport type BaseEndpointDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  ResultType\n> = (\n  | ([CastAny<BaseQueryResult<BaseQuery>, {}>] extends [NEVER]\n      ? never\n      : EndpointDefinitionWithQuery<QueryArg, BaseQuery, ResultType>)\n  | EndpointDefinitionWithQueryFn<QueryArg, BaseQuery, ResultType>\n) & {\n  /* phantom type */\n  [resultType]?: ResultType\n  /* phantom type */\n  [baseQuery]?: BaseQuery\n} & HasRequiredProps<\n    BaseQueryExtraOptions<BaseQuery>,\n    { extraOptions: BaseQueryExtraOptions<BaseQuery> },\n    { extraOptions?: BaseQueryExtraOptions<BaseQuery> }\n  >\n\nexport enum DefinitionType {\n  query = 'query',\n  mutation = 'mutation',\n}\n\nexport type GetResultDescriptionFn<\n  TagTypes extends string,\n  ResultType,\n  QueryArg,\n  ErrorType\n> = (\n  result: ResultType | undefined,\n  error: ErrorType | undefined,\n  arg: QueryArg\n) => ReadonlyArray<TagDescription<TagTypes>>\n\nexport type FullTagDescription<TagType> = {\n  type: TagType\n  id?: number | string\n}\nexport type TagDescription<TagType> = TagType | FullTagDescription<TagType>\nexport type ResultDescription<\n  TagTypes extends string,\n  ResultType,\n  QueryArg,\n  ErrorType\n> =\n  | ReadonlyArray<TagDescription<TagTypes>>\n  | GetResultDescriptionFn<TagTypes, ResultType, QueryArg, ErrorType>\n\n/** @deprecated please use `onQueryStarted` instead */\nexport interface QueryApi<ReducerPath extends string, Context extends {}> {\n  /** @deprecated please use `onQueryStarted` instead */\n  dispatch: ThunkDispatch<any, any, AnyAction>\n  /** @deprecated please use `onQueryStarted` instead */\n  getState(): RootState<any, any, ReducerPath>\n  /** @deprecated please use `onQueryStarted` instead */\n  extra: unknown\n  /** @deprecated please use `onQueryStarted` instead */\n  requestId: string\n  /** @deprecated please use `onQueryStarted` instead */\n  context: Context\n}\n\nexport interface QueryExtraOptions<\n  TagTypes extends string,\n  ResultType,\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  ReducerPath extends string = string\n> {\n  type: DefinitionType.query\n  /**\n   * Used by `query` endpoints. Determines which 'tag' is attached to the cached data returned by the query.\n   * Expects an array of tag type strings, an array of objects of tag types with ids, or a function that returns such an array.\n   * 1.  `['Post']` - equivalent to `2`\n   * 2.  `[{ type: 'Post' }]` - equivalent to `1`\n   * 3.  `[{ type: 'Post', id: 1 }]`\n   * 4.  `(result, error, arg) => ['Post']` - equivalent to `5`\n   * 5.  `(result, error, arg) => [{ type: 'Post' }]` - equivalent to `4`\n   * 6.  `(result, error, arg) => [{ type: 'Post', id: 1 }]`\n   *\n   * @example\n   *\n   * ```ts\n   * // codeblock-meta title=\"providesTags example\"\n   *\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   tagTypes: ['Posts'],\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       query: () => 'posts',\n   *       // highlight-start\n   *       providesTags: (result) =>\n   *         result\n   *           ? [\n   *               ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n   *               { type: 'Posts', id: 'LIST' },\n   *             ]\n   *           : [{ type: 'Posts', id: 'LIST' }],\n   *       // highlight-end\n   *     })\n   *   })\n   * })\n   * ```\n   */\n  providesTags?: ResultDescription<\n    TagTypes,\n    ResultType,\n    QueryArg,\n    BaseQueryError<BaseQuery>\n  >\n  /**\n   * Not to be used. A query should not invalidate tags in the cache.\n   */\n  invalidatesTags?: never\n}\n\nexport type QueryDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  QueryExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\nexport interface MutationExtraOptions<\n  TagTypes extends string,\n  ResultType,\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  ReducerPath extends string = string\n> {\n  type: DefinitionType.mutation\n  /**\n   * Used by `mutation` endpoints. Determines which cached data should be either re-fetched or removed from the cache.\n   * Expects the same shapes as `providesTags`.\n   *\n   * @example\n   *\n   * ```ts\n   * // codeblock-meta title=\"invalidatesTags example\"\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   tagTypes: ['Posts'],\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       query: () => 'posts',\n   *       providesTags: (result) =>\n   *         result\n   *           ? [\n   *               ...result.map(({ id }) => ({ type: 'Posts' as const, id })),\n   *               { type: 'Posts', id: 'LIST' },\n   *             ]\n   *           : [{ type: 'Posts', id: 'LIST' }],\n   *     }),\n   *     addPost: build.mutation<Post, Partial<Post>>({\n   *       query(body) {\n   *         return {\n   *           url: `posts`,\n   *           method: 'POST',\n   *           body,\n   *         }\n   *       },\n   *       // highlight-start\n   *       invalidatesTags: [{ type: 'Posts', id: 'LIST' }],\n   *       // highlight-end\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  invalidatesTags?: ResultDescription<\n    TagTypes,\n    ResultType,\n    QueryArg,\n    BaseQueryError<BaseQuery>\n  >\n  /**\n   * Not to be used. A mutation should not provide tags to the cache.\n   */\n  providesTags?: never\n}\n\nexport type MutationDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string\n> = BaseEndpointDefinition<QueryArg, BaseQuery, ResultType> &\n  MutationExtraOptions<TagTypes, ResultType, QueryArg, BaseQuery, ReducerPath>\n\nexport type EndpointDefinition<\n  QueryArg,\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ResultType,\n  ReducerPath extends string = string\n> =\n  | QueryDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n  | MutationDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n\nexport type EndpointDefinitions = Record<\n  string,\n  EndpointDefinition<any, any, any, any>\n>\n\nexport function isQueryDefinition(\n  e: EndpointDefinition<any, any, any, any>\n): e is QueryDefinition<any, any, any, any> {\n  return e.type === DefinitionType.query\n}\n\nexport function isMutationDefinition(\n  e: EndpointDefinition<any, any, any, any>\n): e is MutationDefinition<any, any, any, any> {\n  return e.type === DefinitionType.mutation\n}\n\nexport type EndpointBuilder<\n  BaseQuery extends BaseQueryFn,\n  TagTypes extends string,\n  ReducerPath extends string\n> = {\n  /**\n   * An endpoint definition that retrieves data, and may provide tags to the cache.\n   *\n   * @example\n   * ```js\n   * // codeblock-meta title=\"Example of all query endpoint options\"\n   * const api = createApi({\n   *  baseQuery,\n   *  endpoints: (build) => ({\n   *    getPost: build.query({\n   *      query: (id) => ({ url: `post/${id}` }),\n   *      // Pick out data and prevent nested properties in a hook or selector\n   *      transformResponse: (response) => response.data,\n   *      // `result` is the server response\n   *      providesTags: (result, error, id) => [{ type: 'Post', id }],\n   *      // trigger side effects or optimistic updates\n   *      onQueryStarted(id, { dispatch, getState, extra, requestId, queryFulfilled, getCacheEntry, updateCachedData }) {},\n   *      // handle subscriptions etc\n   *      onCacheEntryAdded(id, { dispatch, getState, extra, requestId, cacheEntryRemoved, cacheDataLoaded, getCacheEntry, updateCachedData }) {},\n   *    }),\n   *  }),\n   *});\n   *```\n   */\n  query<ResultType, QueryArg>(\n    definition: OmitFromUnion<\n      QueryDefinition<QueryArg, BaseQuery, TagTypes, ResultType>,\n      'type'\n    >\n  ): QueryDefinition<QueryArg, BaseQuery, TagTypes, ResultType>\n  /**\n   * An endpoint definition that alters data on the server or will possibly invalidate the cache.\n   *\n   * @example\n   * ```js\n   * // codeblock-meta title=\"Example of all mutation endpoint options\"\n   * const api = createApi({\n   *   baseQuery,\n   *   endpoints: (build) => ({\n   *     updatePost: build.mutation({\n   *       query: ({ id, ...patch }) => ({ url: `post/${id}`, method: 'PATCH', body: patch }),\n   *       // Pick out data and prevent nested properties in a hook or selector\n   *       transformResponse: (response) => response.data,\n   *       // `result` is the server response\n   *       invalidatesTags: (result, error, id) => [{ type: 'Post', id }],\n   *      // trigger side effects or optimistic updates\n   *      onQueryStarted(id, { dispatch, getState, extra, requestId, queryFulfilled, getCacheEntry }) {},\n   *      // handle subscriptions etc\n   *      onCacheEntryAdded(id, { dispatch, getState, extra, requestId, cacheEntryRemoved, cacheDataLoaded, getCacheEntry }) {},\n   *     }),\n   *   }),\n   * });\n   * ```\n   */\n  mutation<ResultType, QueryArg>(\n    definition: OmitFromUnion<\n      MutationDefinition<\n        QueryArg,\n        BaseQuery,\n        TagTypes,\n        ResultType,\n        ReducerPath\n      >,\n      'type'\n    >\n  ): MutationDefinition<QueryArg, BaseQuery, TagTypes, ResultType, ReducerPath>\n}\n\nexport type AssertTagTypes = <T extends FullTagDescription<string>>(t: T) => T\n\nexport function calculateProvidedBy<ResultType, QueryArg, ErrorType>(\n  description:\n    | ResultDescription<string, ResultType, QueryArg, ErrorType>\n    | undefined,\n  result: ResultType | undefined,\n  error: ErrorType | undefined,\n  queryArg: QueryArg,\n  assertTagTypes: AssertTagTypes\n): readonly FullTagDescription<string>[] {\n  if (isFunction(description)) {\n    return description(result as ResultType, error as undefined, queryArg)\n      .map(expandTagDescription)\n      .map(assertTagTypes)\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes)\n  }\n  return []\n}\n\nfunction isFunction<T>(t: T): t is Extract<T, Function> {\n  return typeof t === 'function'\n}\n\nfunction expandTagDescription(\n  description: TagDescription<string>\n): FullTagDescription<string> {\n  return typeof description === 'string' ? { type: description } : description\n}\n\nexport type QueryArgFrom<\n  D extends BaseEndpointDefinition<any, any, any>\n> = D extends BaseEndpointDefinition<infer QA, any, any> ? QA : unknown\nexport type ResultTypeFrom<\n  D extends BaseEndpointDefinition<any, any, any>\n> = D extends BaseEndpointDefinition<any, any, infer RT> ? RT : unknown\n\nexport type ReducerPathFrom<\n  D extends EndpointDefinition<any, any, any, any>\n> = D extends EndpointDefinition<any, any, any, infer RP> ? RP : unknown\n\nexport type TagTypesFrom<\n  D extends EndpointDefinition<any, any, any, any>\n> = D extends EndpointDefinition<any, any, infer RP, any> ? RP : unknown\n\nexport type ReplaceTagTypes<\n  Definitions extends EndpointDefinitions,\n  NewTagTypes extends string\n> = {\n  [K in keyof Definitions]: Definitions[K] extends QueryDefinition<\n    infer QueryArg,\n    infer BaseQuery,\n    any,\n    infer ResultType,\n    infer ReducerPath\n  >\n    ? QueryDefinition<QueryArg, BaseQuery, NewTagTypes, ResultType, ReducerPath>\n    : Definitions[K] extends MutationDefinition<\n        infer QueryArg,\n        infer BaseQuery,\n        any,\n        infer ResultType,\n        infer ReducerPath\n      >\n    ? MutationDefinition<\n        QueryArg,\n        BaseQuery,\n        NewTagTypes,\n        ResultType,\n        ReducerPath\n      >\n    : never\n}\n","export function capitalize(str: string) {\n  return str.replace(str[0], str[0].toUpperCase())\n}\n","export type Id<T> = { [K in keyof T]: T[K] } & {}\nexport type WithRequiredProp<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Override<T1, T2> = T2 extends any ? Omit<T1, keyof T2> & T2 : never\nexport function assertCast<T>(v: any): asserts v is T {}\n\nexport function safeAssign<T extends object>(\n  target: T,\n  ...args: Array<Partial<NoInfer<T>>>\n) {\n  Object.assign(target, ...args)\n}\n\n/**\n * Convert a Union type `(A|B)` to an intersection type `(A&B)`\n */\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type NonOptionalKeys<T> = {\n  [K in keyof T]-?: undefined extends T[K] ? never : K\n}[keyof T]\n\nexport type HasRequiredProps<T, True, False> = NonOptionalKeys<T> extends never\n  ? False\n  : True\n\nexport type OptionalIfAllPropsOptional<T> = HasRequiredProps<T, T, T | never>\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport type UnwrapPromise<T> = T extends PromiseLike<infer V> ? V : T\n\nexport type MaybePromise<T> = T | PromiseLike<T>\n\nexport type OmitFromUnion<T, K extends keyof T> = T extends any\n  ? Omit<T, K>\n  : never\n\nexport type IsAny<T, True, False = never> = true | false extends (\n  T extends never ? true : false\n)\n  ? True\n  : False\n\nexport type CastAny<T, CastTo> = IsAny<T, CastTo, T>\n","import type { MutationHooks, QueryHooks } from './buildHooks'\nimport { buildHooks } from './buildHooks'\nimport { isQueryDefinition, isMutationDefinition } from '../endpointDefinitions'\nimport type {\n  EndpointDefinitions,\n  QueryDefinition,\n  MutationDefinition,\n  QueryArgFrom,\n} from '@reduxjs/toolkit/dist/query/endpointDefinitions'\nimport type { Api, Module } from '../apiTypes'\nimport { capitalize } from '../utils'\nimport { safeAssign } from '../tsHelpers'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/dist/query/baseQueryTypes'\n\nimport type { HooksWithUniqueNames } from './versionedTypes'\n\nimport {\n  useDispatch as rrUseDispatch,\n  useSelector as rrUseSelector,\n  useStore as rrUseStore,\n  batch as rrBatch,\n} from 'react-redux'\nimport type { QueryKeys } from '../core/apiState'\nimport type { PrefetchOptions } from '../core/module'\n\nexport const reactHooksModuleName = /* @__PURE__ */ Symbol()\nexport type ReactHooksModule = typeof reactHooksModuleName\n\ndeclare module '@reduxjs/toolkit/dist/query/apiTypes' {\n  export interface ApiModules<\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    BaseQuery extends BaseQueryFn,\n    Definitions extends EndpointDefinitions,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ReducerPath extends string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    TagTypes extends string\n  > {\n    [reactHooksModuleName]: {\n      /**\n       *  Endpoints based on the input endpoints provided to `createApi`, containing `select`, `hooks` and `action matchers`.\n       */\n      endpoints: {\n        [K in keyof Definitions]: Definitions[K] extends QueryDefinition<\n          any,\n          any,\n          any,\n          any,\n          any\n        >\n          ? QueryHooks<Definitions[K]>\n          : Definitions[K] extends MutationDefinition<any, any, any, any, any>\n          ? MutationHooks<Definitions[K]>\n          : never\n      }\n      /**\n       * A hook that accepts a string endpoint name, and provides a callback that when called, pre-fetches the data for that endpoint.\n       */\n      usePrefetch<EndpointName extends QueryKeys<Definitions>>(\n        endpointName: EndpointName,\n        options?: PrefetchOptions\n      ): (\n        arg: QueryArgFrom<Definitions[EndpointName]>,\n        options?: PrefetchOptions\n      ) => void\n    } & HooksWithUniqueNames<Definitions>\n  }\n}\n\ntype RR = typeof import('react-redux')\n\nexport interface ReactHooksModuleOptions {\n  /**\n   * The version of the `batchedUpdates` function to be used\n   */\n  batch?: RR['batch']\n  /**\n   * The version of the `useDispatch` hook to be used\n   */\n  useDispatch?: RR['useDispatch']\n  /**\n   * The version of the `useSelector` hook to be used\n   */\n  useSelector?: RR['useSelector']\n  /**\n   * The version of the `useStore` hook to be used\n   */\n  useStore?: RR['useStore']\n}\n\n/**\n * Creates a module that generates react hooks from endpoints, for use with `buildCreateApi`.\n *\n *  @example\n * ```ts\n * const MyContext = React.createContext<ReactReduxContextValue>(null as any);\n * const customCreateApi = buildCreateApi(\n *   coreModule(),\n *   reactHooksModule({ useDispatch: createDispatchHook(MyContext) })\n * );\n * ```\n *\n * @returns A module for use with `buildCreateApi`\n */\nexport const reactHooksModule = ({\n  batch = rrBatch,\n  useDispatch = rrUseDispatch,\n  useSelector = rrUseSelector,\n  useStore = rrUseStore,\n}: ReactHooksModuleOptions = {}): Module<ReactHooksModule> => ({\n  name: reactHooksModuleName,\n  init(api, options, context) {\n    const anyApi = (api as any) as Api<\n      any,\n      Record<string, any>,\n      string,\n      string,\n      ReactHooksModule\n    >\n    const { buildQueryHooks, buildMutationHook, usePrefetch } = buildHooks({\n      api,\n      moduleOptions: { batch, useDispatch, useSelector, useStore },\n    })\n    safeAssign(anyApi, { usePrefetch })\n    safeAssign(context, { batch })\n\n    return {\n      injectEndpoint(endpointName, definition) {\n        if (isQueryDefinition(definition)) {\n          const {\n            useQuery,\n            useLazyQuery,\n            useLazyQuerySubscription,\n            useQueryState,\n            useQuerySubscription,\n          } = buildQueryHooks(endpointName)\n          safeAssign(anyApi.endpoints[endpointName], {\n            useQuery,\n            useLazyQuery,\n            useLazyQuerySubscription,\n            useQueryState,\n            useQuerySubscription,\n          })\n          ;(api as any)[`use${capitalize(endpointName)}Query`] = useQuery\n          ;(api as any)[\n            `useLazy${capitalize(endpointName)}Query`\n          ] = useLazyQuery\n        } else if (isMutationDefinition(definition)) {\n          const useMutation = buildMutationHook(endpointName)\n          safeAssign(anyApi.endpoints[endpointName], {\n            useMutation,\n          })\n          ;(api as any)[`use${capitalize(endpointName)}Mutation`] = useMutation\n        }\n      },\n    }\n  },\n})\n","import { configureStore } from '@reduxjs/toolkit'\nimport type { Context } from 'react';\nimport React from 'react'\nimport type { ReactReduxContextValue } from 'react-redux';\nimport { Provider } from 'react-redux'\nimport { setupListeners } from '@reduxjs/toolkit/query'\nimport type { Api } from '@reduxjs/toolkit/dist/query/apiTypes'\n\n/**\n * Can be used as a `Provider` if you **do not already have a Redux store**.\n *\n * @example\n * ```tsx\n * // codeblock-meta title=\"Basic usage - wrap your App with ApiProvider\"\n * import * as React from 'react';\n * import { ApiProvider } from '@reduxjs/toolkit/query/react';\n * import { Pokemon } from './features/Pokemon';\n *\n * function App() {\n *   return (\n *     <ApiProvider api={api}>\n *       <Pokemon />\n *     </ApiProvider>\n *   );\n * }\n * ```\n *\n * @remarks\n * Using this together with an existing redux store, both will\n * conflict with each other - please use the traditional redux setup\n * in that case.\n */\nexport function ApiProvider<A extends Api<any, {}, any, any>>(props: {\n  children: any\n  api: A\n  setupListeners?: Parameters<typeof setupListeners>[1]\n  context?: Context<ReactReduxContextValue>\n}) {\n  const [store] = React.useState(() =>\n    configureStore({\n      reducer: {\n        [props.api.reducerPath]: props.api.reducer,\n      },\n      middleware: (gDM) => gDM().concat(props.api.middleware),\n    })\n  )\n  // Adds the event listeners for online/offline/focus/etc\n  setupListeners(store.dispatch, props.setupListeners)\n\n  return (\n    <Provider store={store} context={props.context}>\n      {props.children}\n    </Provider>\n  )\n}\n"]}
